{
  "version": 3,
  "sources": ["../../../../../node_modules/src/utils.ts", "../../../../../node_modules/src/query-ref.ts", "../../../../../node_modules/src/tokens.ts", "../../../../../node_modules/src/apollo.ts", "../../../../../node_modules/src/apollo-module.ts", "../../../../../node_modules/src/query.ts", "../../../../../node_modules/src/mutation.ts", "../../../../../node_modules/src/subscription.ts", "../../../../../node_modules/src/gql.ts", "../../../../../node_modules/src/ngApollo.ts"],
  "sourcesContent": ["import type { SchedulerAction, SchedulerLike, Subscription } from 'rxjs';\nimport { Observable, observable, queueScheduler } from 'rxjs';\nimport { map, observeOn, startWith } from 'rxjs/operators';\nimport { NgZone } from '@angular/core';\nimport type {\n  Observable as AObservable,\n  ApolloQueryResult,\n  FetchResult,\n  ObservableQuery,\n} from '@apollo/client/core';\nimport type { MutationResult } from './types';\n\nexport function fromPromise<T>(promiseFn: () => Promise<T>): Observable<T> {\n  return new Observable<T>(subscriber => {\n    promiseFn().then(\n      result => {\n        if (!subscriber.closed) {\n          subscriber.next(result);\n          subscriber.complete();\n        }\n      },\n      error => {\n        if (!subscriber.closed) {\n          subscriber.error(error);\n        }\n      },\n    );\n\n    return () => subscriber.unsubscribe();\n  });\n}\n\nexport function useMutationLoading<T>(source: Observable<FetchResult<T>>, enabled: boolean) {\n  if (!enabled) {\n    return source.pipe(\n      map<FetchResult<T>, MutationResult<T>>(result => ({\n        ...result,\n        loading: false,\n      })),\n    );\n  }\n\n  return source.pipe(\n    startWith<MutationResult<T>>({\n      loading: true,\n    }),\n    map<MutationResult<T>, MutationResult<T>>(result => ({\n      ...result,\n      loading: !!result.loading,\n    })),\n  );\n}\n\nexport class ZoneScheduler implements SchedulerLike {\n  constructor(private zone: NgZone) {}\n\n  public now = Date.now ? Date.now : () => +new Date();\n\n  public schedule<T>(\n    work: (this: SchedulerAction<T>, state?: T) => void,\n    delay: number = 0,\n    state?: T,\n  ): Subscription {\n    return this.zone.run(() => queueScheduler.schedule(work, delay, state)) as Subscription;\n  }\n}\n\n// XXX: Apollo's QueryObservable is not compatible with RxJS\n// TODO: remove it in one of future releases\n// https://github.com/ReactiveX/rxjs/blob/9fb0ce9e09c865920cf37915cc675e3b3a75050b/src/internal/util/subscribeTo.ts#L32\nexport function fixObservable<T>(obs: ObservableQuery<T>): Observable<ApolloQueryResult<T>>;\nexport function fixObservable<T>(obs: AObservable<T>): Observable<T>;\nexport function fixObservable<T>(\n  obs: AObservable<T> | ObservableQuery<T>,\n): Observable<ApolloQueryResult<T>> | Observable<T> {\n  (obs as any)[observable] = () => obs;\n  return obs as any;\n}\n\nexport function wrapWithZone<T>(obs: Observable<T>, ngZone: NgZone): Observable<T> {\n  return obs.pipe(observeOn(new ZoneScheduler(ngZone)));\n}\n\nexport function pickFlag<TFlags, K extends keyof TFlags>(\n  flags: TFlags | undefined,\n  flag: K,\n  defaultValue: TFlags[K],\n): TFlags[K] {\n  return flags && typeof flags[flag] !== 'undefined' ? flags[flag] : defaultValue;\n}\n", "import { from, Observable } from 'rxjs';\nimport { NgZone } from '@angular/core';\nimport type {\n  ApolloError,\n  ApolloQueryResult,\n  FetchMoreQueryOptions,\n  ObservableQuery,\n  OperationVariables,\n  SubscribeToMoreOptions,\n  TypedDocumentNode,\n  UpdateQueryOptions,\n} from '@apollo/client/core';\nimport { NetworkStatus } from '@apollo/client/core';\nimport { EmptyObject, WatchQueryOptions } from './types';\nimport { fixObservable, wrapWithZone } from './utils';\n\nfunction useInitialLoading<T, V extends OperationVariables>(obsQuery: ObservableQuery<T, V>) {\n  return function useInitialLoadingOperator<T>(source: Observable<T>): Observable<T> {\n    return new Observable(function useInitialLoadingSubscription(subscriber) {\n      const currentResult = obsQuery.getCurrentResult();\n      const { loading, errors, error, partial, data } = currentResult;\n      const { partialRefetch, fetchPolicy } = obsQuery.options;\n\n      const hasError = errors || error;\n\n      if (\n        partialRefetch &&\n        partial &&\n        (!data || Object.keys(data).length === 0) &&\n        fetchPolicy !== 'cache-only' &&\n        !loading &&\n        !hasError\n      ) {\n        subscriber.next({\n          ...currentResult,\n          loading: true,\n          networkStatus: NetworkStatus.loading,\n        } as any);\n      }\n\n      return source.subscribe(subscriber);\n    });\n  };\n}\n\nexport type QueryRefFromDocument<T extends TypedDocumentNode> = T extends TypedDocumentNode<\n  infer R,\n  infer V\n>\n  ? QueryRef<R, V & OperationVariables>\n  : never;\n\nexport class QueryRef<T, V extends OperationVariables = EmptyObject> {\n  public valueChanges: Observable<ApolloQueryResult<T>>;\n  public queryId: ObservableQuery<T, V>['queryId'];\n\n  constructor(\n    private obsQuery: ObservableQuery<T, V>,\n    ngZone: NgZone,\n    options: WatchQueryOptions<V, T>,\n  ) {\n    const wrapped = wrapWithZone(from(fixObservable(this.obsQuery)), ngZone);\n\n    this.valueChanges = options.useInitialLoading\n      ? wrapped.pipe(useInitialLoading(this.obsQuery))\n      : wrapped;\n    this.queryId = this.obsQuery.queryId;\n  }\n\n  // ObservableQuery's methods\n\n  public get options() {\n    return this.obsQuery.options;\n  }\n\n  public get variables() {\n    return this.obsQuery.variables;\n  }\n\n  public result(): Promise<ApolloQueryResult<T>> {\n    return this.obsQuery.result();\n  }\n\n  public getCurrentResult(): ApolloQueryResult<T> {\n    return this.obsQuery.getCurrentResult();\n  }\n\n  public getLastResult(): ApolloQueryResult<T> {\n    return this.obsQuery.getLastResult();\n  }\n\n  public getLastError(): ApolloError {\n    return this.obsQuery.getLastError();\n  }\n\n  public resetLastResults(): void {\n    return this.obsQuery.resetLastResults();\n  }\n\n  public refetch(variables?: V): Promise<ApolloQueryResult<T>> {\n    return this.obsQuery.refetch(variables);\n  }\n\n  public fetchMore<K = V>(\n    fetchMoreOptions: FetchMoreQueryOptions<K, T>,\n  ): Promise<ApolloQueryResult<T>> {\n    return this.obsQuery.fetchMore(fetchMoreOptions);\n  }\n\n  public subscribeToMore<MT = any, MV = EmptyObject>(\n    options: SubscribeToMoreOptions<T, MV, MT>,\n  ): () => void {\n    // XXX: there's a bug in apollo-client typings\n    // it should not inherit types from ObservableQuery\n    return this.obsQuery.subscribeToMore(options as any);\n  }\n  public updateQuery(mapFn: (previousQueryResult: T, options: UpdateQueryOptions<V>) => T): void {\n    return this.obsQuery.updateQuery(mapFn);\n  }\n\n  public stopPolling(): void {\n    return this.obsQuery.stopPolling();\n  }\n\n  public startPolling(pollInterval: number): void {\n    return this.obsQuery.startPolling(pollInterval);\n  }\n\n  public setOptions(opts: any) {\n    return this.obsQuery.setOptions(opts);\n  }\n\n  public setVariables(variables: V) {\n    return this.obsQuery.setVariables(variables);\n  }\n}\n", "import { InjectionToken } from '@angular/core';\nimport type { ApolloClientOptions } from '@apollo/client/core';\nimport type { Flags, NamedOptions } from './types';\n\nexport const APOLLO_FLAGS = new InjectionToken<Flags>('APOLLO_FLAGS');\n\nexport const APOLLO_OPTIONS = new InjectionToken<ApolloClientOptions<any>>('APOLLO_OPTIONS');\n\nexport const APOLLO_NAMED_OPTIONS = new InjectionToken<NamedOptions>('APOLLO_NAMED_OPTIONS');\n", "import { from, Observable } from 'rxjs';\nimport { Inject, Injectable, NgZone, Optional } from '@angular/core';\nimport type {\n  ApolloClientOptions,\n  ApolloQueryResult,\n  FetchResult,\n  ObservableQuery,\n  OperationVariables,\n  QueryOptions,\n  SubscriptionOptions,\n} from '@apollo/client/core';\nimport { ApolloClient } from '@apollo/client/core';\nimport { QueryRef } from './query-ref';\nimport { APOLLO_FLAGS, APOLLO_NAMED_OPTIONS, APOLLO_OPTIONS } from './tokens';\nimport type {\n  EmptyObject,\n  ExtraSubscriptionOptions,\n  Flags,\n  MutationOptions,\n  MutationResult,\n  NamedOptions,\n  WatchQueryOptions,\n} from './types';\nimport { fixObservable, fromPromise, pickFlag, useMutationLoading, wrapWithZone } from './utils';\n\nexport class ApolloBase<TCacheShape = any> {\n  private useInitialLoading: boolean;\n  private useMutationLoading: boolean;\n\n  constructor(\n    protected ngZone: NgZone,\n    protected flags?: Flags,\n    protected _client?: ApolloClient<TCacheShape>,\n  ) {\n    this.useInitialLoading = pickFlag(flags, 'useInitialLoading', false);\n    this.useMutationLoading = pickFlag(flags, 'useMutationLoading', false);\n  }\n\n  public watchQuery<TData, TVariables extends OperationVariables = EmptyObject>(\n    options: WatchQueryOptions<TVariables, TData>,\n  ): QueryRef<TData, TVariables> {\n    return new QueryRef<TData, TVariables>(\n      this.ensureClient().watchQuery<TData, TVariables>({\n        ...options,\n      }) as ObservableQuery<TData, TVariables>,\n      this.ngZone,\n      {\n        useInitialLoading: this.useInitialLoading,\n        ...options,\n      },\n    );\n  }\n\n  public query<T, V = EmptyObject>(options: QueryOptions<V, T>): Observable<ApolloQueryResult<T>> {\n    return fromPromise<ApolloQueryResult<T>>(() => this.ensureClient().query<T, V>({ ...options }));\n  }\n\n  public mutate<T, V = EmptyObject>(options: MutationOptions<T, V>): Observable<MutationResult<T>> {\n    return useMutationLoading(\n      fromPromise(() => this.ensureClient().mutate<T, V>({ ...options })),\n      options.useMutationLoading ?? this.useMutationLoading,\n    );\n  }\n\n  public subscribe<T, V = EmptyObject>(\n    options: SubscriptionOptions<V, T>,\n    extra?: ExtraSubscriptionOptions,\n  ): Observable<FetchResult<T>> {\n    const obs = from(fixObservable(this.ensureClient().subscribe<T, V>({ ...options })));\n\n    return extra && extra.useZone !== true ? obs : wrapWithZone(obs, this.ngZone);\n  }\n\n  /**\n   * Get an instance of ApolloClient\n   * @deprecated use `apollo.client` instead\n   */\n  public getClient() {\n    return this.client;\n  }\n\n  /**\n   * Set a new instance of ApolloClient\n   * Remember to clean up the store before setting a new client.\n   * @deprecated use `apollo.client = client` instead\n   *\n   * @param client ApolloClient instance\n   */\n  public setClient(client: ApolloClient<TCacheShape>) {\n    this.client = client;\n  }\n\n  /**\n   * Get an instance of ApolloClient\n   */\n  public get client(): ApolloClient<TCacheShape> {\n    return this._client;\n  }\n\n  /**\n   * Set a new instance of ApolloClient\n   * Remember to clean up the store before setting a new client.\n   *\n   * @param client ApolloClient instance\n   */\n  public set client(client: ApolloClient<TCacheShape>) {\n    if (this._client) {\n      throw new Error('Client has been already defined');\n    }\n\n    this._client = client;\n  }\n\n  private ensureClient() {\n    this.checkInstance();\n\n    return this._client;\n  }\n\n  private checkInstance(): void {\n    if (!this._client) {\n      throw new Error('Client has not been defined yet');\n    }\n  }\n}\n\n@Injectable()\nexport class Apollo extends ApolloBase<any> {\n  private map: Map<string, ApolloBase<any>> = new Map<string, ApolloBase<any>>();\n\n  constructor(\n    private _ngZone: NgZone,\n    @Optional()\n    @Inject(APOLLO_OPTIONS)\n    apolloOptions?: ApolloClientOptions<any>,\n    @Inject(APOLLO_NAMED_OPTIONS) @Optional() apolloNamedOptions?: NamedOptions,\n    @Inject(APOLLO_FLAGS) @Optional() flags?: Flags,\n  ) {\n    super(_ngZone, flags);\n\n    if (apolloOptions) {\n      this.createDefault(apolloOptions);\n    }\n\n    if (apolloNamedOptions && typeof apolloNamedOptions === 'object') {\n      for (let name in apolloNamedOptions) {\n        if (apolloNamedOptions.hasOwnProperty(name)) {\n          const options = apolloNamedOptions[name];\n          this.create(options, name);\n        }\n      }\n    }\n  }\n\n  /**\n   * Create an instance of ApolloClient\n   * @param options Options required to create ApolloClient\n   * @param name client's name\n   */\n  public create<TCacheShape>(options: ApolloClientOptions<TCacheShape>, name?: string): void {\n    if (isDefault(name)) {\n      this.createDefault<TCacheShape>(options);\n    } else {\n      this.createNamed<TCacheShape>(name, options);\n    }\n  }\n\n  /**\n   * Use a default ApolloClient\n   */\n  public default(): ApolloBase<any> {\n    return this;\n  }\n\n  /**\n   * Use a named ApolloClient\n   * @param name client's name\n   */\n  public use(name: string): ApolloBase<any> {\n    if (isDefault(name)) {\n      return this.default();\n    }\n    return this.map.get(name);\n  }\n\n  /**\n   * Create a default ApolloClient, same as `apollo.create(options)`\n   * @param options ApolloClient's options\n   */\n  public createDefault<TCacheShape>(options: ApolloClientOptions<TCacheShape>): void {\n    if (this.getClient()) {\n      throw new Error('Apollo has been already created.');\n    }\n\n    return this.setClient(new ApolloClient<TCacheShape>(options));\n  }\n\n  /**\n   * Create a named ApolloClient, same as `apollo.create(options, name)`\n   * @param name client's name\n   * @param options ApolloClient's options\n   */\n  public createNamed<TCacheShape>(name: string, options: ApolloClientOptions<TCacheShape>): void {\n    if (this.map.has(name)) {\n      throw new Error(`Client ${name} has been already created`);\n    }\n    this.map.set(\n      name,\n      new ApolloBase(this._ngZone, this.flags, new ApolloClient<TCacheShape>(options)),\n    );\n  }\n\n  /**\n   * Remember to clean up the store before removing a client\n   * @param name client's name\n   */\n  public removeClient(name?: string): void {\n    if (isDefault(name)) {\n      this._client = undefined;\n    } else {\n      this.map.delete(name);\n    }\n  }\n}\n\nfunction isDefault(name?: string): boolean {\n  return !name || name === 'default';\n}\n", "import { NgModule } from '@angular/core';\nimport { Apollo } from './apollo';\n\nexport const PROVIDERS = [Apollo];\n\n@NgModule({\n  providers: PROVIDERS,\n})\nexport class ApolloModule {}\n", "import type { DocumentNode } from 'graphql';\nimport type { Observable } from 'rxjs';\nimport { Injectable } from '@angular/core';\nimport type { ApolloQueryResult, OperationVariables, TypedDocumentNode } from '@apollo/client/core';\nimport { Apollo } from './apollo';\nimport { QueryRef } from './query-ref';\nimport { EmptyObject, QueryOptionsAlone, WatchQueryOptionsAlone } from './types';\n\n@Injectable()\nexport class Query<T = {}, V extends OperationVariables = EmptyObject> {\n  public readonly document: DocumentNode | TypedDocumentNode<T, V>;\n  public client = 'default';\n\n  constructor(protected apollo: Apollo) {}\n\n  public watch(variables?: V, options?: WatchQueryOptionsAlone<V, T>): QueryRef<T, V> {\n    return this.apollo.use(this.client).watchQuery<T, V>({\n      ...options,\n      variables,\n      query: this.document,\n    });\n  }\n\n  public fetch(variables?: V, options?: QueryOptionsAlone<V, T>): Observable<ApolloQueryResult<T>> {\n    return this.apollo.use(this.client).query<T, V>({\n      ...options,\n      variables,\n      query: this.document,\n    });\n  }\n}\n", "import type { DocumentNode } from 'graphql';\nimport type { Observable } from 'rxjs';\nimport { Injectable } from '@angular/core';\nimport type { TypedDocumentNode } from '@apollo/client/core';\nimport { Apollo } from './apollo';\nimport type { EmptyObject, MutationOptionsAlone, MutationResult } from './types';\n\n@Injectable()\nexport class Mutation<T = {}, V = EmptyObject> {\n  public readonly document: DocumentNode | TypedDocumentNode<T, V>;\n  public client = 'default';\n\n  constructor(protected apollo: Apollo) {}\n\n  public mutate(\n    variables?: V,\n    options?: MutationOptionsAlone<T, V>,\n  ): Observable<MutationResult<T>> {\n    return this.apollo.use(this.client).mutate<T, V>({\n      ...options,\n      variables,\n      mutation: this.document,\n    });\n  }\n}\n", "import type { DocumentNode } from 'graphql';\nimport type { Observable } from 'rxjs';\nimport { Injectable } from '@angular/core';\nimport type { TypedDocumentNode } from '@apollo/client/core';\nimport { Apollo } from './apollo';\nimport {\n  EmptyObject,\n  ExtraSubscriptionOptions,\n  SubscriptionOptionsAlone,\n  SubscriptionResult,\n} from './types';\n\n@Injectable()\nexport class Subscription<T = any, V = EmptyObject> {\n  public readonly document: DocumentNode | TypedDocumentNode<T, V>;\n  public client = 'default';\n\n  constructor(protected apollo: Apollo) {}\n\n  public subscribe(\n    variables?: V,\n    options?: SubscriptionOptionsAlone<V, T>,\n    extra?: ExtraSubscriptionOptions,\n  ): Observable<SubscriptionResult<T>> {\n    return this.apollo.use(this.client).subscribe<T, V>(\n      {\n        ...options,\n        variables,\n        query: this.document,\n      },\n      extra,\n    );\n  }\n}\n", "import { gql as gqlTag, TypedDocumentNode } from '@apollo/client/core';\n\nfunction typedGQLTag<Result, Variables>(\n  literals: ReadonlyArray<string> | Readonly<string>,\n  ...placeholders: any[]\n): TypedDocumentNode<Result, Variables> {\n  return gqlTag(literals, ...placeholders);\n}\n\nexport const gql = typedGQLTag;\nexport const graphql = typedGQLTag;\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],
  "mappings": "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",
  "names": ["fromPromise", "promiseFn", "Observable", "subscriber", "then", "result", "closed", "next", "complete", "error", "unsubscribe", "useMutationLoading", "source", "enabled", "pipe", "map", "loading", "startWith", "ZoneScheduler", "zone", "constructor", "now", "Date", "schedule", "work", "delay", "state", "run", "queueScheduler", "fixObservable", "obs", "observable", "wrapWithZone", "ngZone", "observeOn", "pickFlag", "flags", "flag", "defaultValue", "useInitialLoading", "obsQuery", "useInitialLoadingOperator", "useInitialLoadingSubscription", "currentResult", "getCurrentResult", "errors", "partial", "data", "partialRefetch", "fetchPolicy", "options", "hasError", "Object", "keys", "length", "networkStatus", "NetworkStatus", "subscribe", "QueryRef", "valueChanges", "queryId", "wrapped", "from", "variables", "getLastResult", "getLastError", "resetLastResults", "refetch", "fetchMore", "fetchMoreOptions", "subscribeToMore", "updateQuery", "mapFn", "stopPolling", "startPolling", "pollInterval", "setOptions", "opts", "setVariables", "APOLLO_FLAGS", "InjectionToken", "APOLLO_OPTIONS", "APOLLO_NAMED_OPTIONS", "ApolloBase", "_client", "watchQuery", "ensureClient", "query", "mutate", "extra", "useZone", "getClient", "client", "setClient", "Error", "checkInstance", "Apollo", "_ngZone", "Map", "apolloOptions", "apolloNamedOptions", "createDefault", "name", "hasOwnProperty", "create", "isDefault", "createNamed", "default", "use", "get", "ApolloClient", "has", "set", "removeClient", "undefined", "delete", "ɵfac", "Apollo_Factory", "t", "ɵɵinject", "NgZone", "ɵɵdefineInjectable", "token", "factory", "ɵsetClassMetadata", "Injectable", "Optional", "Inject", "PROVIDERS", "ApolloModule", "ɵɵdefineNgModule", "type", "ɵinj", "ɵɵdefineInjector", "providers", "NgModule", "args", "Query", "apollo", "document", "watch", "fetch", "Mutation", "mutation", "Subscription", "typedGQLTag", "literals", "placeholders", "gql$1", "gql", "graphql"]
}
