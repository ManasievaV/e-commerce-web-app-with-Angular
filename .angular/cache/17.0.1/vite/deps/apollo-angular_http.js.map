{
  "version": 3,
  "sources": ["../../../../../node_modules/@apollo/src/link/batch/batching.ts", "../../../../../node_modules/@apollo/src/link/batch/batchLink.ts", "../../../../../node_modules/http/src/utils.ts", "../../../../../node_modules/http/src/http-link.ts", "../../../../../node_modules/http/src/http-batch-link.ts", "../../../../../node_modules/http/src/index.ts", "../../../../../node_modules/http/src/ngApolloLinkHttp.ts"],
  "sourcesContent": ["import type { FetchResult, NextLink, Operation } from \"../core/index.js\";\nimport type { ObservableSubscription } from \"../../utilities/index.js\";\nimport { Observable } from \"../../utilities/index.js\";\n\nexport type BatchHandler = (\n  operations: Operation[],\n  forward?: (NextLink | undefined)[]\n) => Observable<FetchResult[]> | null;\n\nexport interface BatchableRequest {\n  operation: Operation;\n  forward?: NextLink;\n}\n\ntype QueuedRequest = BatchableRequest & {\n  observable?: Observable<FetchResult>;\n  next: Array<(result: FetchResult) => void>;\n  error: Array<(error: Error) => void>;\n  complete: Array<() => void>;\n  subscribers: Set<object>;\n};\n\n// Batches are primarily a Set<QueuedRequest>, but may have other optional\n// properties, such as batch.subscription.\ntype RequestBatch = Set<QueuedRequest> & {\n  subscription?: ObservableSubscription;\n};\n\n// QueryBatcher doesn't fire requests immediately. Requests that were enqueued within\n// a certain amount of time (configurable through `batchInterval`) will be batched together\n// into one query.\nexport class OperationBatcher {\n  // Queue on which the QueryBatcher will operate on a per-tick basis.\n  private batchesByKey = new Map<string, RequestBatch>();\n\n  private scheduledBatchTimerByKey = new Map<\n    string,\n    ReturnType<typeof setTimeout>\n  >();\n  private batchDebounce?: boolean;\n  private batchInterval?: number;\n  private batchMax: number;\n\n  //This function is called to the queries in the queue to the server.\n  private batchHandler: BatchHandler;\n  private batchKey: (operation: Operation) => string;\n\n  constructor({\n    batchDebounce,\n    batchInterval,\n    batchMax,\n    batchHandler,\n    batchKey,\n  }: {\n    batchDebounce?: boolean;\n    batchInterval?: number;\n    batchMax?: number;\n    batchHandler: BatchHandler;\n    batchKey?: (operation: Operation) => string;\n  }) {\n    this.batchDebounce = batchDebounce;\n    this.batchInterval = batchInterval;\n    this.batchMax = batchMax || 0;\n    this.batchHandler = batchHandler;\n    this.batchKey = batchKey || (() => \"\");\n  }\n\n  public enqueueRequest(request: BatchableRequest): Observable<FetchResult> {\n    const requestCopy: QueuedRequest = {\n      ...request,\n      next: [],\n      error: [],\n      complete: [],\n      subscribers: new Set(),\n    };\n\n    const key = this.batchKey(request.operation);\n\n    if (!requestCopy.observable) {\n      requestCopy.observable = new Observable<FetchResult>((observer) => {\n        let batch = this.batchesByKey.get(key)!;\n        if (!batch) this.batchesByKey.set(key, (batch = new Set()));\n\n        // These booleans seem to me (@benjamn) like they might always be the\n        // same (and thus we could do with only one of them), but I'm not 100%\n        // sure about that.\n        const isFirstEnqueuedRequest = batch.size === 0;\n        const isFirstSubscriber = requestCopy.subscribers.size === 0;\n        requestCopy.subscribers.add(observer);\n        if (isFirstSubscriber) {\n          batch.add(requestCopy);\n        }\n\n        // called for each subscriber, so need to save all listeners (next, error, complete)\n        if (observer.next) {\n          requestCopy.next.push(observer.next.bind(observer));\n        }\n\n        if (observer.error) {\n          requestCopy.error.push(observer.error.bind(observer));\n        }\n\n        if (observer.complete) {\n          requestCopy.complete.push(observer.complete.bind(observer));\n        }\n\n        // The first enqueued request triggers the queue consumption after `batchInterval` milliseconds.\n        if (isFirstEnqueuedRequest || this.batchDebounce) {\n          this.scheduleQueueConsumption(key);\n        }\n\n        // When amount of requests reaches `batchMax`, trigger the queue consumption without waiting on the `batchInterval`.\n        if (batch.size === this.batchMax) {\n          this.consumeQueue(key);\n        }\n\n        return () => {\n          // If this is last subscriber for this request, remove request from queue\n          if (\n            requestCopy.subscribers.delete(observer) &&\n            requestCopy.subscribers.size < 1\n          ) {\n            // If this is last request from queue, remove queue entirely\n            if (batch.delete(requestCopy) && batch.size < 1) {\n              this.consumeQueue(key);\n              // If queue was in flight, cancel it\n              batch.subscription?.unsubscribe();\n            }\n          }\n        };\n      });\n    }\n\n    return requestCopy.observable;\n  }\n\n  // Consumes the queue.\n  // Returns a list of promises (one for each query).\n  public consumeQueue(\n    key: string = \"\"\n  ): (Observable<FetchResult> | undefined)[] | undefined {\n    const batch = this.batchesByKey.get(key);\n    // Delete this batch and process it below.\n    this.batchesByKey.delete(key);\n    if (!batch || !batch.size) {\n      // No requests to be processed.\n      return;\n    }\n\n    const operations: QueuedRequest[\"operation\"][] = [];\n    const forwards: QueuedRequest[\"forward\"][] = [];\n    const observables: QueuedRequest[\"observable\"][] = [];\n    const nexts: QueuedRequest[\"next\"][] = [];\n    const errors: QueuedRequest[\"error\"][] = [];\n    const completes: QueuedRequest[\"complete\"][] = [];\n\n    // Even though batch is a Set, it preserves the order of first insertion\n    // when iterating (per ECMAScript specification), so these requests will be\n    // handled in the order they were enqueued (minus any deleted ones).\n    batch.forEach((request) => {\n      operations.push(request.operation);\n      forwards.push(request.forward);\n      observables.push(request.observable);\n      nexts.push(request.next);\n      errors.push(request.error);\n      completes.push(request.complete);\n    });\n\n    const batchedObservable =\n      this.batchHandler(operations, forwards) || Observable.of();\n\n    const onError = (error: Error) => {\n      //each callback list in batch\n      errors.forEach((rejecters) => {\n        if (rejecters) {\n          //each subscriber to request\n          rejecters.forEach((e) => e(error));\n        }\n      });\n    };\n\n    batch.subscription = batchedObservable.subscribe({\n      next: (results) => {\n        if (!Array.isArray(results)) {\n          results = [results];\n        }\n\n        if (nexts.length !== results.length) {\n          const error = new Error(\n            `server returned results with length ${results.length}, expected length of ${nexts.length}`\n          );\n          (error as any).result = results;\n\n          return onError(error);\n        }\n\n        results.forEach((result, index) => {\n          if (nexts[index]) {\n            nexts[index].forEach((next) => next(result));\n          }\n        });\n      },\n      error: onError,\n      complete: () => {\n        completes.forEach((complete) => {\n          if (complete) {\n            //each subscriber to request\n            complete.forEach((c) => c());\n          }\n        });\n      },\n    });\n\n    return observables;\n  }\n\n  private scheduleQueueConsumption(key: string): void {\n    clearTimeout(this.scheduledBatchTimerByKey.get(key));\n    this.scheduledBatchTimerByKey.set(\n      key,\n      setTimeout(() => {\n        this.consumeQueue(key);\n        this.scheduledBatchTimerByKey.delete(key);\n      }, this.batchInterval)\n    );\n  }\n}\n", "import type { Operation, FetchResult, NextLink } from \"../core/index.js\";\nimport { ApolloLink } from \"../core/index.js\";\nimport type { Observable } from \"../../utilities/index.js\";\nimport type { BatchHandler } from \"./batching.js\";\nimport { OperationBatcher } from \"./batching.js\";\nexport type { BatchableRequest, BatchHandler } from \"./batching.js\";\nexport { OperationBatcher } from \"./batching.js\";\n\nexport namespace BatchLink {\n  export interface Options {\n    /**\n     * The interval at which to batch, in milliseconds.\n     *\n     * Defaults to 10.\n     */\n    batchInterval?: number;\n\n    /**\n     * \"batchInterval\" is a throttling behavior by default, if you instead wish\n     * to debounce outbound requests, set \"batchDebounce\" to true. More useful\n     * for mutations than queries.\n     */\n    batchDebounce?: boolean;\n\n    /**\n     * The maximum number of operations to include in one fetch.\n     *\n     * Defaults to 0 (infinite operations within the interval).\n     */\n    batchMax?: number;\n\n    /**\n     * The handler that should execute a batch of operations.\n     */\n    batchHandler?: BatchHandler;\n\n    /**\n     * creates the key for a batch\n     */\n    batchKey?: (operation: Operation) => string;\n  }\n}\n\nexport class BatchLink extends ApolloLink {\n  private batcher: OperationBatcher;\n\n  constructor(fetchParams?: BatchLink.Options) {\n    super();\n\n    const {\n      batchDebounce,\n      batchInterval = 10,\n      batchMax = 0,\n      batchHandler = () => null,\n      batchKey = () => \"\",\n    } = fetchParams || {};\n\n    this.batcher = new OperationBatcher({\n      batchDebounce,\n      batchInterval,\n      batchMax,\n      batchHandler,\n      batchKey,\n    });\n\n    //make this link terminating\n    if (fetchParams!.batchHandler!.length <= 1) {\n      this.request = (operation) => this.batcher.enqueueRequest({ operation });\n    }\n  }\n\n  public request(\n    operation: Operation,\n    forward?: NextLink\n  ): Observable<FetchResult> | null {\n    return this.batcher.enqueueRequest({\n      operation,\n      forward,\n    });\n  }\n}\n", "import { Observable } from 'rxjs';\nimport { HttpClient, HttpHeaders, HttpResponse } from '@angular/common/http';\nimport { Body, ExtractFiles, Request } from './types';\n\nexport const fetch = (\n  req: Request,\n  httpClient: HttpClient,\n  extractFiles?: ExtractFiles,\n): Observable<HttpResponse<Object>> => {\n  const shouldUseBody = ['POST', 'PUT', 'PATCH'].indexOf(req.method.toUpperCase()) !== -1;\n  const shouldStringify = (param: string) =>\n    ['variables', 'extensions'].indexOf(param.toLowerCase()) !== -1;\n  const isBatching = (req.body as Body[]).length;\n  let shouldUseMultipart = req.options && req.options.useMultipart;\n  let multipartInfo: {\n    clone: Body;\n    files: Map<any, any>;\n  };\n\n  if (shouldUseMultipart) {\n    if (isBatching) {\n      return new Observable(observer =>\n        observer.error(new Error('File upload is not available when combined with Batching')),\n      );\n    }\n\n    if (!shouldUseBody) {\n      return new Observable(observer =>\n        observer.error(new Error('File upload is not available when GET is used')),\n      );\n    }\n\n    if (!extractFiles) {\n      return new Observable(observer =>\n        observer.error(\n          new Error(\n            `To use File upload you need to pass \"extractFiles\" function from \"extract-files\" library to HttpLink's options`,\n          ),\n        ),\n      );\n    }\n\n    multipartInfo = extractFiles(req.body);\n\n    shouldUseMultipart = !!multipartInfo.files.size;\n  }\n\n  // `body` for some, `params` for others\n  let bodyOrParams = {};\n\n  if (isBatching) {\n    if (!shouldUseBody) {\n      return new Observable(observer =>\n        observer.error(new Error('Batching is not available for GET requests')),\n      );\n    }\n\n    bodyOrParams = {\n      body: req.body,\n    };\n  } else {\n    const body = shouldUseMultipart ? multipartInfo!.clone : req.body;\n\n    if (shouldUseBody) {\n      bodyOrParams = {\n        body,\n      };\n    } else {\n      const params = Object.keys(req.body).reduce((obj: any, param) => {\n        const value = (req.body as any)[param];\n        obj[param] = shouldStringify(param) ? JSON.stringify(value) : value;\n        return obj;\n      }, {});\n\n      bodyOrParams = { params: params };\n    }\n  }\n\n  if (shouldUseMultipart && shouldUseBody) {\n    const form = new FormData();\n\n    form.append('operations', JSON.stringify((bodyOrParams as any).body));\n\n    const map: Record<string, any> = {};\n    const files = multipartInfo!.files;\n\n    let i = 0;\n    files.forEach(paths => {\n      map[++i] = paths;\n    });\n\n    form.append('map', JSON.stringify(map));\n\n    i = 0;\n    files.forEach((_, file) => {\n      form.append(++i + '', file, file.name);\n    });\n\n    (bodyOrParams as any).body = form;\n  }\n\n  // create a request\n  return httpClient.request<Object>(req.method, req.url, {\n    observe: 'response',\n    responseType: 'json',\n    reportProgress: false,\n    ...bodyOrParams,\n    ...req.options,\n  });\n};\n\nexport const mergeHeaders = (source: HttpHeaders, destination: HttpHeaders): HttpHeaders => {\n  if (source && destination) {\n    const merged = destination\n      .keys()\n      .reduce((headers, name) => headers.set(name, destination.getAll(name)), source);\n\n    return merged;\n  }\n\n  return destination || source;\n};\n\nexport function prioritize<T>(...values: T[]): T {\n  const picked = values.find(val => typeof val !== 'undefined');\n\n  if (typeof picked === 'undefined') {\n    return values[values.length - 1];\n  }\n\n  return picked;\n}\n\nexport function createHeadersWithClientAwareness(context: Record<string, any>) {\n  // `apollographql-client-*` headers are automatically set if a\n  // `clientAwareness` object is found in the context. These headers are\n  // set first, followed by the rest of the headers pulled from\n  // `context.headers`.\n  let headers =\n    context.headers && context.headers instanceof HttpHeaders\n      ? context.headers\n      : new HttpHeaders(context.headers);\n\n  if (context.clientAwareness) {\n    const { name, version } = context.clientAwareness;\n\n    // If desired, `apollographql-client-*` headers set by\n    // the `clientAwareness` object can be overridden by\n    // `apollographql-client-*` headers set in `context.headers`.\n\n    if (name && !headers.has('apollographql-client-name')) {\n      headers = headers.set('apollographql-client-name', name);\n    }\n\n    if (version && !headers.has('apollographql-client-version')) {\n      headers = headers.set('apollographql-client-version', version);\n    }\n  }\n\n  return headers;\n}\n", "import { print } from 'graphql';\nimport { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport {\n  ApolloLink,\n  FetchResult,\n  Observable as LinkObservable,\n  Operation,\n} from '@apollo/client/core';\nimport { Body, Context, OperationPrinter, Options, Request } from './types';\nimport { createHeadersWithClientAwareness, fetch, mergeHeaders, prioritize } from './utils';\n\n// XXX find a better name for it\nexport class HttpLinkHandler extends ApolloLink {\n  public requester: (operation: Operation) => LinkObservable<FetchResult> | null;\n  private print: OperationPrinter = print;\n\n  constructor(\n    private httpClient: HttpClient,\n    private options: Options,\n  ) {\n    super();\n\n    if (this.options.operationPrinter) {\n      this.print = this.options.operationPrinter;\n    }\n\n    this.requester = (operation: Operation) =>\n      new LinkObservable((observer: any) => {\n        const context: Context = operation.getContext();\n\n        // decides which value to pick, Context, Options or to just use the default\n        const pick = <K extends keyof Context>(\n          key: K,\n          init?: Context[K] | Options[K],\n        ): Context[K] | Options[K] => {\n          return prioritize(context[key], this.options[key], init);\n        };\n\n        let method = pick('method', 'POST');\n        const includeQuery = pick('includeQuery', true);\n        const includeExtensions = pick('includeExtensions', false);\n        const url = pick('uri', 'graphql');\n        const withCredentials = pick('withCredentials');\n        const useMultipart = pick('useMultipart');\n        const useGETForQueries = this.options.useGETForQueries === true;\n\n        const isQuery = operation.query.definitions.some(\n          def => def.kind === 'OperationDefinition' && def.operation === 'query',\n        );\n\n        if (useGETForQueries && isQuery) {\n          method = 'GET';\n        }\n\n        const req: Request = {\n          method,\n          url: typeof url === 'function' ? url(operation) : url,\n          body: {\n            operationName: operation.operationName,\n            variables: operation.variables,\n          },\n          options: {\n            withCredentials,\n            useMultipart,\n            headers: this.options.headers,\n          },\n        };\n\n        if (includeExtensions) {\n          (req.body as Body).extensions = operation.extensions;\n        }\n\n        if (includeQuery) {\n          (req.body as Body).query = this.print(operation.query);\n        }\n\n        const headers = createHeadersWithClientAwareness(context);\n\n        req.options.headers = mergeHeaders(req.options.headers, headers);\n\n        const sub = fetch(req, this.httpClient, this.options.extractFiles).subscribe({\n          next: response => {\n            operation.setContext({ response });\n            observer.next(response.body);\n          },\n          error: err => observer.error(err),\n          complete: () => observer.complete(),\n        });\n\n        return () => {\n          if (!sub.closed) {\n            sub.unsubscribe();\n          }\n        };\n      });\n  }\n\n  public request(op: Operation): LinkObservable<FetchResult> | null {\n    return this.requester(op);\n  }\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class HttpLink {\n  constructor(private httpClient: HttpClient) {}\n\n  public create(options: Options): HttpLinkHandler {\n    return new HttpLinkHandler(this.httpClient, options);\n  }\n}\n", "import { print } from 'graphql';\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport {\n  ApolloLink,\n  FetchResult,\n  Observable as LinkObservable,\n  Operation,\n} from '@apollo/client/core';\nimport { BatchHandler, BatchLink } from '@apollo/client/link/batch';\nimport { BatchOptions, Body, Context, OperationPrinter, Options, Request } from './types';\nimport { createHeadersWithClientAwareness, fetch, mergeHeaders, prioritize } from './utils';\n\nconst defaults = {\n  batchInterval: 10,\n  batchMax: 10,\n  uri: 'graphql',\n  method: 'POST',\n};\n\nexport class HttpBatchLinkHandler extends ApolloLink {\n  public batcher: ApolloLink;\n  private batchInterval: number;\n  private batchMax: number;\n  private print: OperationPrinter = print;\n\n  constructor(\n    private httpClient: HttpClient,\n    private options: BatchOptions,\n  ) {\n    super();\n\n    this.batchInterval = options.batchInterval || defaults.batchInterval;\n    this.batchMax = options.batchMax || defaults.batchMax;\n\n    if (this.options.operationPrinter) {\n      this.print = this.options.operationPrinter;\n    }\n\n    const batchHandler: BatchHandler = (operations: Operation[]) => {\n      return new LinkObservable((observer: any) => {\n        const body = this.createBody(operations);\n        const headers = this.createHeaders(operations);\n        const { method, uri, withCredentials } = this.createOptions(operations);\n\n        if (typeof uri === 'function') {\n          throw new Error(`Option 'uri' is a function, should be a string`);\n        }\n\n        const req: Request = {\n          method,\n          url: uri,\n          body: body,\n          options: {\n            withCredentials,\n            headers,\n          },\n        };\n\n        const sub = fetch(req, this.httpClient, () => {\n          throw new Error('File upload is not available when combined with Batching');\n        }).subscribe({\n          next: result => observer.next(result.body),\n          error: err => observer.error(err),\n          complete: () => observer.complete(),\n        });\n\n        return () => {\n          if (!sub.closed) {\n            sub.unsubscribe();\n          }\n        };\n      });\n    };\n\n    const batchKey =\n      options.batchKey ||\n      ((operation: Operation) => {\n        return this.createBatchKey(operation);\n      });\n\n    this.batcher = new BatchLink({\n      batchInterval: this.batchInterval,\n      batchMax: this.batchMax,\n      batchKey,\n      batchHandler,\n    });\n  }\n\n  private createOptions(operations: Operation[]): Options {\n    const context: Context = operations[0].getContext();\n\n    return {\n      method: prioritize(context.method, this.options.method, defaults.method),\n      uri: prioritize(context.uri, this.options.uri, defaults.uri),\n      withCredentials: prioritize(context.withCredentials, this.options.withCredentials),\n    };\n  }\n\n  private createBody(operations: Operation[]): Body[] {\n    return operations.map(operation => {\n      const includeExtensions = prioritize(\n        operation.getContext().includeExtensions,\n        this.options.includeExtensions,\n        false,\n      );\n      const includeQuery = prioritize(\n        operation.getContext().includeQuery,\n        this.options.includeQuery,\n        true,\n      );\n\n      const body: Body = {\n        operationName: operation.operationName,\n        variables: operation.variables,\n      };\n\n      if (includeExtensions) {\n        body.extensions = operation.extensions;\n      }\n\n      if (includeQuery) {\n        body.query = this.print(operation.query);\n      }\n\n      return body;\n    });\n  }\n\n  private createHeaders(operations: Operation[]): HttpHeaders {\n    return operations.reduce(\n      (headers: HttpHeaders, operation: Operation) => {\n        return mergeHeaders(headers, operation.getContext().headers);\n      },\n      createHeadersWithClientAwareness({\n        headers: this.options.headers,\n        clientAwareness: operations[0]?.getContext()?.clientAwareness,\n      }),\n    );\n  }\n\n  private createBatchKey(operation: Operation): string {\n    const context: Context & { skipBatching?: boolean } = operation.getContext();\n\n    if (context.skipBatching) {\n      return Math.random().toString(36).substr(2, 9);\n    }\n\n    const headers =\n      context.headers && context.headers.keys().map((k: string) => context.headers.get(k));\n\n    const opts = JSON.stringify({\n      includeQuery: context.includeQuery,\n      includeExtensions: context.includeExtensions,\n      headers,\n    });\n\n    return prioritize(context.uri, this.options.uri) + opts;\n  }\n\n  public request(op: Operation): LinkObservable<FetchResult> | null {\n    return this.batcher.request(op);\n  }\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class HttpBatchLink {\n  constructor(private httpClient: HttpClient) {}\n\n  public create(options: BatchOptions): HttpBatchLinkHandler {\n    return new HttpBatchLinkHandler(this.httpClient, options);\n  }\n}\n", "// http\nexport { HttpLink, HttpLinkHandler } from './http-link';\n// http-batch\nexport { HttpBatchLink, HttpBatchLinkHandler } from './http-batch-link';\n// common\nexport { BatchOptions, Options } from './types';\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],
  "mappings": "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",
  "names": ["OperationBatcher", "Observable", "BatchLink", "fetch", "req", "httpClient", "extractFiles", "shouldUseBody", "indexOf", "method", "toUpperCase", "shouldStringify", "param", "toLowerCase", "isBatching", "body", "length", "shouldUseMultipart", "options", "useMultipart", "multipartInfo", "Observable", "observer", "error", "Error", "files", "size", "bodyOrParams", "clone", "params", "Object", "keys", "reduce", "obj", "value", "JSON", "stringify", "form", "FormData", "append", "map", "i", "forEach", "paths", "_", "file", "name", "request", "url", "observe", "responseType", "reportProgress", "mergeHeaders", "source", "destination", "merged", "headers", "set", "getAll", "prioritize", "values", "picked", "find", "val", "createHeadersWithClientAwareness", "context", "HttpHeaders", "clientAwareness", "version", "has", "HttpLinkHandler", "ApolloLink", "requester", "print", "constructor", "operationPrinter", "operation", "Observable$1", "getContext", "pick", "key", "init", "includeQuery", "includeExtensions", "withCredentials", "useGETForQueries", "isQuery", "query", "definitions", "some", "def", "kind", "operationName", "variables", "extensions", "sub", "subscribe", "next", "response", "setContext", "err", "complete", "closed", "unsubscribe", "op", "HttpLink", "create", "HttpClient", "ɵprov", "factory", "ɵfac", "providedIn", "Injectable", "args", "defaults", "batchInterval", "batchMax", "uri", "HttpBatchLinkHandler", "batcher", "batchHandler", "operations", "createBody", "createHeaders", "createOptions", "result", "batchKey", "createBatchKey", "BatchLink", "skipBatching", "Math", "random", "toString", "substr", "k", "get", "opts", "HttpBatchLink"]
}
